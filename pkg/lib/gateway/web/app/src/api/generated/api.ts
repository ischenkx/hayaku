/* tslint:disable */
/* eslint-disable */
/**
 * Kantoku API
 * Create and execute distributed workflows
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnyValue
 */
export interface AnyValue {
}
/**
 * 
 * @export
 * @interface InfoCursor
 */
export interface InfoCursor {
    /**
     * 
     * @type {number}
     * @memberof InfoCursor
     */
    'skip'?: number;
    /**
     * 
     * @type {number}
     * @memberof InfoCursor
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<RecordMask>}
     * @memberof InfoCursor
     */
    'masks'?: Array<RecordMask>;
    /**
     * 
     * @type {Array<RecordSorter>}
     * @memberof InfoCursor
     */
    'sort'?: Array<RecordSorter>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoCursor
     */
    'distinct'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A human readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RecordMask
 */
export interface RecordMask {
    /**
     * 
     * @type {string}
     * @memberof RecordMask
     */
    'operation': string;
    /**
     * 
     * @type {string}
     * @memberof RecordMask
     */
    'property_pattern': string;
}
/**
 * 
 * @export
 * @interface RecordSorter
 */
export interface RecordSorter {
    /**
     * 
     * @type {string}
     * @memberof RecordSorter
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof RecordSorter
     */
    'ordering': string;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ResourceInitializer
 */
export interface ResourceInitializer {
    /**
     * 
     * @type {string}
     * @memberof ResourceInitializer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceInitializer
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface Specification
 */
export interface Specification {
    /**
     * 
     * @type {string}
     * @memberof Specification
     */
    'id': string;
    /**
     * 
     * @type {SpecificationIO}
     * @memberof Specification
     */
    'io': SpecificationIO;
    /**
     * 
     * @type {SpecificationExecutable}
     * @memberof Specification
     */
    'executable': SpecificationExecutable;
    /**
     * 
     * @type {object}
     * @memberof Specification
     */
    'meta': object;
}
/**
 * 
 * @export
 * @interface SpecificationBasedTaskParameters
 */
export interface SpecificationBasedTaskParameters {
    /**
     * 
     * @type {Array<string>}
     * @memberof SpecificationBasedTaskParameters
     */
    'parameters': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SpecificationBasedTaskParameters
     */
    'specification': string;
    /**
     * 
     * @type {object}
     * @memberof SpecificationBasedTaskParameters
     */
    'info': object;
}
/**
 * 
 * @export
 * @interface SpecificationExecutable
 */
export interface SpecificationExecutable {
    /**
     * 
     * @type {string}
     * @memberof SpecificationExecutable
     */
    'type': string;
    /**
     * 
     * @type {object}
     * @memberof SpecificationExecutable
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface SpecificationIO
 */
export interface SpecificationIO {
    /**
     * 
     * @type {SpecificationResourceSet}
     * @memberof SpecificationIO
     */
    'inputs': SpecificationResourceSet;
    /**
     * 
     * @type {SpecificationResourceSet}
     * @memberof SpecificationIO
     */
    'outputs': SpecificationResourceSet;
}
/**
 * 
 * @export
 * @interface SpecificationResourceSet
 */
export interface SpecificationResourceSet {
    /**
     * 
     * @type {Array<SpecificationResourceSetNamingInner>}
     * @memberof SpecificationResourceSet
     */
    'naming': Array<SpecificationResourceSetNamingInner>;
    /**
     * 
     * @type {Array<SpecificationResourceSetTypesInner>}
     * @memberof SpecificationResourceSet
     */
    'types': Array<SpecificationResourceSetTypesInner>;
}
/**
 * 
 * @export
 * @interface SpecificationResourceSetNamingInner
 */
export interface SpecificationResourceSetNamingInner {
    /**
     * 
     * @type {number}
     * @memberof SpecificationResourceSetNamingInner
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof SpecificationResourceSetNamingInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SpecificationResourceSetTypesInner
 */
export interface SpecificationResourceSetTypesInner {
    /**
     * 
     * @type {number}
     * @memberof SpecificationResourceSetTypesInner
     */
    'index': number;
    /**
     * 
     * @type {Type}
     * @memberof SpecificationResourceSetTypesInner
     */
    'type': Type;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {Array<string>}
     * @memberof Task
     */
    'inputs': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Task
     */
    'outputs': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof Task
     */
    'info': object;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TaskParameters
 */
export interface TaskParameters {
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskParameters
     */
    'inputs': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskParameters
     */
    'outputs': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof TaskParameters
     */
    'info': object;
}
/**
 * 
 * @export
 * @interface TaskSpawnResponse
 */
export interface TaskSpawnResponse {
    /**
     * 
     * @type {string}
     * @memberof TaskSpawnResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TaskStorageCommand
 */
export interface TaskStorageCommand {
    /**
     * 
     * @type {string}
     * @memberof TaskStorageCommand
     */
    'operation': string;
    /**
     * 
     * @type {Array<TaskStorageCommandParam>}
     * @memberof TaskStorageCommand
     */
    'params': Array<TaskStorageCommandParam>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TaskStorageCommand
     */
    'meta': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TaskStorageCommandParam
 */
export interface TaskStorageCommandParam {
    /**
     * 
     * @type {string}
     * @memberof TaskStorageCommandParam
     */
    'name': string;
    /**
     * 
     * @type {AnyValue}
     * @memberof TaskStorageCommandParam
     */
    'value': AnyValue;
}
/**
 * 
 * @export
 * @interface TaskStorageSettings
 */
export interface TaskStorageSettings {
    /**
     * 
     * @type {string}
     * @memberof TaskStorageSettings
     */
    'type': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TaskStorageSettings
     */
    'meta': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TasksRestartPostRequest
 */
export interface TasksRestartPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TasksRestartPostRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TasksStorageGetWithPropertiesPostRequest
 */
export interface TasksStorageGetWithPropertiesPostRequest {
    /**
     * 
     * @type {{ [key: string]: Array<AnyValue>; }}
     * @memberof TasksStorageGetWithPropertiesPostRequest
     */
    'properties_to_values': { [key: string]: Array<AnyValue>; };
}
/**
 * 
 * @export
 * @interface TasksStorageUpdateByIdsPostRequest
 */
export interface TasksStorageUpdateByIdsPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof TasksStorageUpdateByIdsPostRequest
     */
    'ids': Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TasksStorageUpdateByIdsPostRequest
     */
    'properties': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TasksStorageUpdateWithPropertiesPost200Response
 */
export interface TasksStorageUpdateWithPropertiesPost200Response {
    /**
     * 
     * @type {number}
     * @memberof TasksStorageUpdateWithPropertiesPost200Response
     */
    'modified': number;
}
/**
 * 
 * @export
 * @interface TasksStorageUpdateWithPropertiesPostRequest
 */
export interface TasksStorageUpdateWithPropertiesPostRequest {
    /**
     * 
     * @type {{ [key: string]: Array<AnyValue>; }}
     * @memberof TasksStorageUpdateWithPropertiesPostRequest
     */
    'properties_to_values': { [key: string]: Array<AnyValue>; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TasksStorageUpdateWithPropertiesPostRequest
     */
    'new_properties': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Type
 */
export interface Type {
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'name': string;
    /**
     * 
     * @type {TypeSubTypes}
     * @memberof Type
     */
    'sub_types': TypeSubTypes;
}
/**
 * 
 * @export
 * @interface TypeSubTypes
 */
export interface TypeSubTypes {
    [key: string]: Type | any;

    /**
     * 
     * @type {Type}
     * @memberof TypeSubTypes
     */
    'default'?: Type;
}
/**
 * 
 * @export
 * @interface TypeWithID
 */
export interface TypeWithID {
    /**
     * 
     * @type {string}
     * @memberof TypeWithID
     */
    'id': string;
    /**
     * 
     * @type {Type}
     * @memberof TypeWithID
     */
    'type': Type;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Allocates N resources
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesAllocatePost: async (amount: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('resourcesAllocatePost', 'amount', amount)
            const localVarPath = `/resources/allocate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deallocate resources
         * @param {Array<string>} requestBody A list of resource identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesDeallocatePost: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('resourcesDeallocatePost', 'requestBody', requestBody)
            const localVarPath = `/resources/deallocate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialize resources
         * @param {Array<ResourceInitializer>} resourceInitializer A dictionary (ResourceID -&gt; Value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesInitializePost: async (resourceInitializer: Array<ResourceInitializer>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceInitializer' is not null or undefined
            assertParamExists('resourcesInitializePost', 'resourceInitializer', resourceInitializer)
            const localVarPath = `/resources/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceInitializer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load resources
         * @param {Array<string>} requestBody A list of resource identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesLoadPost: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('resourcesLoadPost', 'requestBody', requestBody)
            const localVarPath = `/resources/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load a set of tasks
         * @param {Array<string>} requestBody A list of task identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksLoadPost: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('tasksLoadPost', 'requestBody', requestBody)
            const localVarPath = `/tasks/load`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart a failed task
         * @param {TasksRestartPostRequest} tasksRestartPostRequest A task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRestartPost: async (tasksRestartPostRequest: TasksRestartPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksRestartPostRequest' is not null or undefined
            assertParamExists('tasksRestartPost', 'tasksRestartPostRequest', tasksRestartPostRequest)
            const localVarPath = `/tasks/restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Spawn a new task from specification
         * @param {SpecificationBasedTaskParameters} specificationBasedTaskParameters The specification of a task to be spawned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpawnFromSpecPost: async (specificationBasedTaskParameters: SpecificationBasedTaskParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specificationBasedTaskParameters' is not null or undefined
            assertParamExists('tasksSpawnFromSpecPost', 'specificationBasedTaskParameters', specificationBasedTaskParameters)
            const localVarPath = `/tasks/spawn_from_spec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specificationBasedTaskParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Spawn a new task
         * @param {TaskParameters} taskParameters The specification of a task to be spawned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpawnPost: async (taskParameters: TaskParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskParameters' is not null or undefined
            assertParamExists('tasksSpawnPost', 'taskParameters', taskParameters)
            const localVarPath = `/tasks/spawn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a specification
         * @param {Specification} specification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsCreatePost: async (specification: Specification, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'specification' is not null or undefined
            assertParamExists('tasksSpecificationsCreatePost', 'specification', specification)
            const localVarPath = `/tasks/specifications/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(specification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all specifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsGetAllPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/specifications/get_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specifications by id
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsGetPost: async (tasksRestartPostRequest: TasksRestartPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksRestartPostRequest' is not null or undefined
            assertParamExists('tasksSpecificationsGetPost', 'tasksRestartPostRequest', tasksRestartPostRequest)
            const localVarPath = `/tasks/specifications/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a specification
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsRemovePost: async (tasksRestartPostRequest: TasksRestartPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksRestartPostRequest' is not null or undefined
            assertParamExists('tasksSpecificationsRemovePost', 'tasksRestartPostRequest', tasksRestartPostRequest)
            const localVarPath = `/tasks/specifications/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a type
         * @param {TypeWithID} typeWithID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesCreatePost: async (typeWithID: TypeWithID, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeWithID' is not null or undefined
            assertParamExists('tasksSpecificationsTypesCreatePost', 'typeWithID', typeWithID)
            const localVarPath = `/tasks/specifications/types/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(typeWithID, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesGetAllPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/specifications/types/get_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a type by id
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesGetPost: async (tasksRestartPostRequest: TasksRestartPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksRestartPostRequest' is not null or undefined
            assertParamExists('tasksSpecificationsTypesGetPost', 'tasksRestartPostRequest', tasksRestartPostRequest)
            const localVarPath = `/tasks/specifications/types/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a type
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesRemovePost: async (tasksRestartPostRequest: TasksRestartPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksRestartPostRequest' is not null or undefined
            assertParamExists('tasksSpecificationsTypesRemovePost', 'tasksRestartPostRequest', tasksRestartPostRequest)
            const localVarPath = `/tasks/specifications/types/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete tasks with the given ids
         * @param {Array<string>} requestBody An array of task ids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageDeletePost: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('tasksStorageDeletePost', 'requestBody', requestBody)
            const localVarPath = `/tasks/storage/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute a command in the task storage
         * @param {TaskStorageCommand} taskStorageCommand A command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageExecPost: async (taskStorageCommand: TaskStorageCommand, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskStorageCommand' is not null or undefined
            assertParamExists('tasksStorageExecPost', 'taskStorageCommand', taskStorageCommand)
            const localVarPath = `/tasks/storage/exec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskStorageCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of tasks by their ids
         * @param {Array<string>} requestBody An array of ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageGetByIdsPost: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('tasksStorageGetByIdsPost', 'requestBody', requestBody)
            const localVarPath = `/tasks/storage/get_by_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tasks with provided properties
         * @param {TasksStorageGetWithPropertiesPostRequest} tasksStorageGetWithPropertiesPostRequest properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageGetWithPropertiesPost: async (tasksStorageGetWithPropertiesPostRequest: TasksStorageGetWithPropertiesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksStorageGetWithPropertiesPostRequest' is not null or undefined
            assertParamExists('tasksStorageGetWithPropertiesPost', 'tasksStorageGetWithPropertiesPostRequest', tasksStorageGetWithPropertiesPostRequest)
            const localVarPath = `/tasks/storage/get_with_properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksStorageGetWithPropertiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert tasks in the database
         * @param {Array<Task>} task An array of tasks to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageInsertPost: async (task: Array<Task>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            assertParamExists('tasksStorageInsertPost', 'task', task)
            const localVarPath = `/tasks/storage/insert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageSettingsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/storage/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update task properties by ids
         * @param {TasksStorageUpdateByIdsPostRequest} tasksStorageUpdateByIdsPostRequest Update info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageUpdateByIdsPost: async (tasksStorageUpdateByIdsPostRequest: TasksStorageUpdateByIdsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksStorageUpdateByIdsPostRequest' is not null or undefined
            assertParamExists('tasksStorageUpdateByIdsPost', 'tasksStorageUpdateByIdsPostRequest', tasksStorageUpdateByIdsPostRequest)
            const localVarPath = `/tasks/storage/update_by_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksStorageUpdateByIdsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update tasks with provided properties
         * @param {TasksStorageUpdateWithPropertiesPostRequest} tasksStorageUpdateWithPropertiesPostRequest properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageUpdateWithPropertiesPost: async (tasksStorageUpdateWithPropertiesPostRequest: TasksStorageUpdateWithPropertiesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasksStorageUpdateWithPropertiesPostRequest' is not null or undefined
            assertParamExists('tasksStorageUpdateWithPropertiesPost', 'tasksStorageUpdateWithPropertiesPostRequest', tasksStorageUpdateWithPropertiesPostRequest)
            const localVarPath = `/tasks/storage/update_with_properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tasksStorageUpdateWithPropertiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Allocates N resources
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourcesAllocatePost(amount: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesAllocatePost(amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deallocate resources
         * @param {Array<string>} requestBody A list of resource identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourcesDeallocatePost(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesDeallocatePost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initialize resources
         * @param {Array<ResourceInitializer>} resourceInitializer A dictionary (ResourceID -&gt; Value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourcesInitializePost(resourceInitializer: Array<ResourceInitializer>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesInitializePost(resourceInitializer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Load resources
         * @param {Array<string>} requestBody A list of resource identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourcesLoadPost(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Resource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesLoadPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Load a set of tasks
         * @param {Array<string>} requestBody A list of task identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksLoadPost(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksLoadPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restart a failed task
         * @param {TasksRestartPostRequest} tasksRestartPostRequest A task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRestartPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksRestartPostRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRestartPost(tasksRestartPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Spawn a new task from specification
         * @param {SpecificationBasedTaskParameters} specificationBasedTaskParameters The specification of a task to be spawned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpawnFromSpecPost(specificationBasedTaskParameters: SpecificationBasedTaskParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSpawnResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpawnFromSpecPost(specificationBasedTaskParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Spawn a new task
         * @param {TaskParameters} taskParameters The specification of a task to be spawned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpawnPost(taskParameters: TaskParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSpawnResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpawnPost(taskParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a specification
         * @param {Specification} specification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsCreatePost(specification: Specification, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsCreatePost(specification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all specifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsGetAllPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Specification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsGetAllPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specifications by id
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsGetPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Specification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsGetPost(tasksRestartPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a specification
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsRemovePost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsRemovePost(tasksRestartPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a type
         * @param {TypeWithID} typeWithID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsTypesCreatePost(typeWithID: TypeWithID, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsTypesCreatePost(typeWithID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsTypesGetAllPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TypeWithID>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsTypesGetAllPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a type by id
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsTypesGetPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TypeWithID>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsTypesGetPost(tasksRestartPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a type
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksSpecificationsTypesRemovePost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksSpecificationsTypesRemovePost(tasksRestartPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete tasks with the given ids
         * @param {Array<string>} requestBody An array of task ids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageDeletePost(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageDeletePost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Execute a command in the task storage
         * @param {TaskStorageCommand} taskStorageCommand A command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageExecPost(taskStorageCommand: TaskStorageCommand, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: any; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageExecPost(taskStorageCommand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of tasks by their ids
         * @param {Array<string>} requestBody An array of ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageGetByIdsPost(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageGetByIdsPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tasks with provided properties
         * @param {TasksStorageGetWithPropertiesPostRequest} tasksStorageGetWithPropertiesPostRequest properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageGetWithPropertiesPost(tasksStorageGetWithPropertiesPostRequest: TasksStorageGetWithPropertiesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageGetWithPropertiesPost(tasksStorageGetWithPropertiesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Insert tasks in the database
         * @param {Array<Task>} task An array of tasks to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageInsertPost(task: Array<Task>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageInsertPost(task, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageSettingsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStorageSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageSettingsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update task properties by ids
         * @param {TasksStorageUpdateByIdsPostRequest} tasksStorageUpdateByIdsPostRequest Update info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageUpdateByIdsPost(tasksStorageUpdateByIdsPostRequest: TasksStorageUpdateByIdsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageUpdateByIdsPost(tasksStorageUpdateByIdsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update tasks with provided properties
         * @param {TasksStorageUpdateWithPropertiesPostRequest} tasksStorageUpdateWithPropertiesPostRequest properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksStorageUpdateWithPropertiesPost(tasksStorageUpdateWithPropertiesPostRequest: TasksStorageUpdateWithPropertiesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksStorageUpdateWithPropertiesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksStorageUpdateWithPropertiesPost(tasksStorageUpdateWithPropertiesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Allocates N resources
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesAllocatePost(amount: number, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.resourcesAllocatePost(amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deallocate resources
         * @param {Array<string>} requestBody A list of resource identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesDeallocatePost(requestBody: Array<string>, options?: any): AxiosPromise<object> {
            return localVarFp.resourcesDeallocatePost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialize resources
         * @param {Array<ResourceInitializer>} resourceInitializer A dictionary (ResourceID -&gt; Value)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesInitializePost(resourceInitializer: Array<ResourceInitializer>, options?: any): AxiosPromise<object> {
            return localVarFp.resourcesInitializePost(resourceInitializer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load resources
         * @param {Array<string>} requestBody A list of resource identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourcesLoadPost(requestBody: Array<string>, options?: any): AxiosPromise<Array<Resource>> {
            return localVarFp.resourcesLoadPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load a set of tasks
         * @param {Array<string>} requestBody A list of task identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksLoadPost(requestBody: Array<string>, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksLoadPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restart a failed task
         * @param {TasksRestartPostRequest} tasksRestartPostRequest A task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRestartPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: any): AxiosPromise<TasksRestartPostRequest> {
            return localVarFp.tasksRestartPost(tasksRestartPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Spawn a new task from specification
         * @param {SpecificationBasedTaskParameters} specificationBasedTaskParameters The specification of a task to be spawned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpawnFromSpecPost(specificationBasedTaskParameters: SpecificationBasedTaskParameters, options?: any): AxiosPromise<TaskSpawnResponse> {
            return localVarFp.tasksSpawnFromSpecPost(specificationBasedTaskParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Spawn a new task
         * @param {TaskParameters} taskParameters The specification of a task to be spawned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpawnPost(taskParameters: TaskParameters, options?: any): AxiosPromise<TaskSpawnResponse> {
            return localVarFp.tasksSpawnPost(taskParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a specification
         * @param {Specification} specification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsCreatePost(specification: Specification, options?: any): AxiosPromise<void> {
            return localVarFp.tasksSpecificationsCreatePost(specification, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all specifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsGetAllPost(options?: any): AxiosPromise<Array<Specification>> {
            return localVarFp.tasksSpecificationsGetAllPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specifications by id
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsGetPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: any): AxiosPromise<Specification> {
            return localVarFp.tasksSpecificationsGetPost(tasksRestartPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a specification
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsRemovePost(tasksRestartPostRequest: TasksRestartPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tasksSpecificationsRemovePost(tasksRestartPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a type
         * @param {TypeWithID} typeWithID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesCreatePost(typeWithID: TypeWithID, options?: any): AxiosPromise<void> {
            return localVarFp.tasksSpecificationsTypesCreatePost(typeWithID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesGetAllPost(options?: any): AxiosPromise<Array<TypeWithID>> {
            return localVarFp.tasksSpecificationsTypesGetAllPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a type by id
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesGetPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: any): AxiosPromise<TypeWithID> {
            return localVarFp.tasksSpecificationsTypesGetPost(tasksRestartPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a type
         * @param {TasksRestartPostRequest} tasksRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksSpecificationsTypesRemovePost(tasksRestartPostRequest: TasksRestartPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tasksSpecificationsTypesRemovePost(tasksRestartPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete tasks with the given ids
         * @param {Array<string>} requestBody An array of task ids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageDeletePost(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.tasksStorageDeletePost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute a command in the task storage
         * @param {TaskStorageCommand} taskStorageCommand A command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageExecPost(taskStorageCommand: TaskStorageCommand, options?: any): AxiosPromise<Array<{ [key: string]: any; }>> {
            return localVarFp.tasksStorageExecPost(taskStorageCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of tasks by their ids
         * @param {Array<string>} requestBody An array of ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageGetByIdsPost(requestBody: Array<string>, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksStorageGetByIdsPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tasks with provided properties
         * @param {TasksStorageGetWithPropertiesPostRequest} tasksStorageGetWithPropertiesPostRequest properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageGetWithPropertiesPost(tasksStorageGetWithPropertiesPostRequest: TasksStorageGetWithPropertiesPostRequest, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.tasksStorageGetWithPropertiesPost(tasksStorageGetWithPropertiesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Insert tasks in the database
         * @param {Array<Task>} task An array of tasks to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageInsertPost(task: Array<Task>, options?: any): AxiosPromise<void> {
            return localVarFp.tasksStorageInsertPost(task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get storage settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageSettingsPost(options?: any): AxiosPromise<TaskStorageSettings> {
            return localVarFp.tasksStorageSettingsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update task properties by ids
         * @param {TasksStorageUpdateByIdsPostRequest} tasksStorageUpdateByIdsPostRequest Update info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageUpdateByIdsPost(tasksStorageUpdateByIdsPostRequest: TasksStorageUpdateByIdsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.tasksStorageUpdateByIdsPost(tasksStorageUpdateByIdsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update tasks with provided properties
         * @param {TasksStorageUpdateWithPropertiesPostRequest} tasksStorageUpdateWithPropertiesPostRequest properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksStorageUpdateWithPropertiesPost(tasksStorageUpdateWithPropertiesPostRequest: TasksStorageUpdateWithPropertiesPostRequest, options?: any): AxiosPromise<TasksStorageUpdateWithPropertiesPost200Response> {
            return localVarFp.tasksStorageUpdateWithPropertiesPost(tasksStorageUpdateWithPropertiesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Allocates N resources
     * @param {number} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourcesAllocatePost(amount: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourcesAllocatePost(amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deallocate resources
     * @param {Array<string>} requestBody A list of resource identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourcesDeallocatePost(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourcesDeallocatePost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialize resources
     * @param {Array<ResourceInitializer>} resourceInitializer A dictionary (ResourceID -&gt; Value)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourcesInitializePost(resourceInitializer: Array<ResourceInitializer>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourcesInitializePost(resourceInitializer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load resources
     * @param {Array<string>} requestBody A list of resource identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resourcesLoadPost(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resourcesLoadPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load a set of tasks
     * @param {Array<string>} requestBody A list of task identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksLoadPost(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksLoadPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restart a failed task
     * @param {TasksRestartPostRequest} tasksRestartPostRequest A task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksRestartPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksRestartPost(tasksRestartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Spawn a new task from specification
     * @param {SpecificationBasedTaskParameters} specificationBasedTaskParameters The specification of a task to be spawned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpawnFromSpecPost(specificationBasedTaskParameters: SpecificationBasedTaskParameters, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpawnFromSpecPost(specificationBasedTaskParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Spawn a new task
     * @param {TaskParameters} taskParameters The specification of a task to be spawned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpawnPost(taskParameters: TaskParameters, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpawnPost(taskParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a specification
     * @param {Specification} specification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsCreatePost(specification: Specification, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsCreatePost(specification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsGetAllPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsGetAllPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specifications by id
     * @param {TasksRestartPostRequest} tasksRestartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsGetPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsGetPost(tasksRestartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a specification
     * @param {TasksRestartPostRequest} tasksRestartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsRemovePost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsRemovePost(tasksRestartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a type
     * @param {TypeWithID} typeWithID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsTypesCreatePost(typeWithID: TypeWithID, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsTypesCreatePost(typeWithID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsTypesGetAllPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsTypesGetAllPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a type by id
     * @param {TasksRestartPostRequest} tasksRestartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsTypesGetPost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsTypesGetPost(tasksRestartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a type
     * @param {TasksRestartPostRequest} tasksRestartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksSpecificationsTypesRemovePost(tasksRestartPostRequest: TasksRestartPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksSpecificationsTypesRemovePost(tasksRestartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete tasks with the given ids
     * @param {Array<string>} requestBody An array of task ids to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageDeletePost(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageDeletePost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute a command in the task storage
     * @param {TaskStorageCommand} taskStorageCommand A command
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageExecPost(taskStorageCommand: TaskStorageCommand, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageExecPost(taskStorageCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of tasks by their ids
     * @param {Array<string>} requestBody An array of ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageGetByIdsPost(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageGetByIdsPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tasks with provided properties
     * @param {TasksStorageGetWithPropertiesPostRequest} tasksStorageGetWithPropertiesPostRequest properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageGetWithPropertiesPost(tasksStorageGetWithPropertiesPostRequest: TasksStorageGetWithPropertiesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageGetWithPropertiesPost(tasksStorageGetWithPropertiesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Insert tasks in the database
     * @param {Array<Task>} task An array of tasks to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageInsertPost(task: Array<Task>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageInsertPost(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get storage settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageSettingsPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageSettingsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update task properties by ids
     * @param {TasksStorageUpdateByIdsPostRequest} tasksStorageUpdateByIdsPostRequest Update info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageUpdateByIdsPost(tasksStorageUpdateByIdsPostRequest: TasksStorageUpdateByIdsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageUpdateByIdsPost(tasksStorageUpdateByIdsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update tasks with provided properties
     * @param {TasksStorageUpdateWithPropertiesPostRequest} tasksStorageUpdateWithPropertiesPostRequest properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tasksStorageUpdateWithPropertiesPost(tasksStorageUpdateWithPropertiesPostRequest: TasksStorageUpdateWithPropertiesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tasksStorageUpdateWithPropertiesPost(tasksStorageUpdateWithPropertiesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


